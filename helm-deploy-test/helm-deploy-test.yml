# Concourse pipeline to build deploy and teardown cf against a kube cluster

resources:
- name: ci
  type: git
  source:
    uri: ((src-ci-repo))
    branch: ((src-ci-branch))
    paths:
    - helm-deploy-test/*

- name: s3.scf-config
  type: s3
  source:
    endpoint: ((s3-config-endpoint))
    access_key_id: ((s3-config-access-key))
    secret_access_key: ((s3-config-secret-key))
    bucket: ((s3-config-bucket))
    regexp: ((s3-config-prefix))scf-(.*).linux-amd64\.zip$

- name: pool.kube-hosts
  type: pool
  source:
    uri: ((kube-pool-repo))
    private_key: ((kube-pool-key))
    branch: ((kube-pool-branch))
    pool: ((kube-pool-pool))

jobs:
- name: helm-deploy-test
  plan:
  - aggregate:
    - get: ci
    - get: s3.scf-config
      trigger: true
    - put: pool.kube-hosts
      params: {acquire: true}
    on_failure:
      put: pool.kube-hosts
      params: {release: pool.kube-hosts}
  - task: cf-deploy
    file: ci/helm-deploy-test/tasks/cf-deploy.yml
  - task: cf-smoke-tests
    file: ci/helm-deploy-test/tasks/run-test.yml
    params:
      TEST_NAME: smoke-tests
  - task: acceptance-tests-brain
    file: ci/helm-deploy-test/tasks/run-test.yml
    params:
      TEST_NAME: acceptance-tests-brain
  - task: acceptance-tests
    file: ci/helm-deploy-test/tasks/run-test.yml
    params:
      TEST_NAME: acceptance-tests

  # We intentionally don't put the teardown and pool release steps in an ensure
  # block, so that when tests fail we have a chance of examining why things are
  # failing.
  - task: cf-teardown
    file: ci/helm-deploy-test/tasks/cf-teardown.yml
  - put: pool.kube-hosts
    params: {release: pool.kube-hosts}
